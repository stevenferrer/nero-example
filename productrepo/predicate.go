// Code generated by nero, DO NOT EDIT.
package productrepo

import (
	"github.com/stevenferrer/nero/comparison"
)

// IDEq equal operator on ID field
func IDEq(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.Eq,
			Arg:   id,
		})
	}
}

// IDNotEq not equal operator on ID field
func IDNotEq(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.NotEq,
			Arg:   id,
		})
	}
}

// IDGt greater than operator on ID field
func IDGt(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.Gt,
			Arg:   id,
		})
	}
}

// IDGtOrEq greater than or equal operator on ID field
func IDGtOrEq(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.GtOrEq,
			Arg:   id,
		})
	}
}

// IDLt less than operator on ID field
func IDLt(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.Lt,
			Arg:   id,
		})
	}
}

// IDLtOrEq less than or equal operator on ID field
func IDLtOrEq(id int64) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.LtOrEq,
			Arg:   id,
		})
	}
}

// IDIn in operator on ID field
func IDIn(ids ...int64) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.In,
			Arg:   args,
		})
	}
}

// IDNotIn not in operator on ID field
func IDNotIn(ids ...int64) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "id",
			Op:    comparison.NotIn,
			Arg:   args,
		})
	}
}

// NameEq equal operator on Name field
func NameEq(name string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "name",
			Op:    comparison.Eq,
			Arg:   name,
		})
	}
}

// NameNotEq not equal operator on Name field
func NameNotEq(name string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "name",
			Op:    comparison.NotEq,
			Arg:   name,
		})
	}
}

// NameIn in operator on Name field
func NameIn(names ...string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "name",
			Op:    comparison.In,
			Arg:   args,
		})
	}
}

// NameNotIn not in operator on Name field
func NameNotIn(names ...string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "name",
			Op:    comparison.NotIn,
			Arg:   args,
		})
	}
}

// CreatedAtEq equal operator on CreatedAt field
func CreatedAtEq(createdAt string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "created_at",
			Op:    comparison.Eq,
			Arg:   createdAt,
		})
	}
}

// CreatedAtNotEq not equal operator on CreatedAt field
func CreatedAtNotEq(createdAt string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "created_at",
			Op:    comparison.NotEq,
			Arg:   createdAt,
		})
	}
}

// CreatedAtIn in operator on CreatedAt field
func CreatedAtIn(createdAts ...string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "created_at",
			Op:    comparison.In,
			Arg:   args,
		})
	}
}

// CreatedAtNotIn not in operator on CreatedAt field
func CreatedAtNotIn(createdAts ...string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "created_at",
			Op:    comparison.NotIn,
			Arg:   args,
		})
	}
}

// UpdatedAtEq equal operator on UpdatedAt field
func UpdatedAtEq(updatedAt *string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.Eq,
			Arg:   updatedAt,
		})
	}
}

// UpdatedAtNotEq not equal operator on UpdatedAt field
func UpdatedAtNotEq(updatedAt *string) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.NotEq,
			Arg:   updatedAt,
		})
	}
}

// UpdatedAtIsNull is null operator on UpdatedAt field
func UpdatedAtIsNull() comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.IsNull,
		})
	}
}

// UpdatedAtIsNotNull is not null operator on UpdatedAt field
func UpdatedAtIsNotNull() comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.IsNotNull,
		})
	}
}

// UpdatedAtIn in operator on UpdatedAt field
func UpdatedAtIn(updatedAts ...*string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.In,
			Arg:   args,
		})
	}
}

// UpdatedAtNotIn not in operator on UpdatedAt field
func UpdatedAtNotIn(updatedAts ...*string) comparison.PredFunc {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: "updated_at",
			Op:    comparison.NotIn,
			Arg:   args,
		})
	}
}

// FieldXEqFieldY fieldX equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXEqFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.Eq,
			Arg:   fieldY,
		})
	}
}

// FieldXNotEqFieldY fieldX not equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXNotEqFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.NotEq,
			Arg:   fieldY,
		})
	}
}

// FieldXGtFieldY fieldX greater than fieldY
//
// fieldX and fieldY must be of the same type
func FieldXGtFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.Gt,
			Arg:   fieldY,
		})
	}
}

// FieldXGtOrEqFieldY fieldX greater than or equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXGtOrEqFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.GtOrEq,
			Arg:   fieldY,
		})
	}
}

// FieldXLtFieldY fieldX less than fieldY
//
// fieldX and fieldY must be of the same type
func FieldXLtFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.Lt,
			Arg:   fieldY,
		})
	}
}

// FieldXLtOrEqFieldY fieldX less than or equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXLtOrEqFieldY(fieldX, fieldY Field) comparison.PredFunc {
	return func(preds []*comparison.Predicate) []*comparison.Predicate {
		return append(preds, &comparison.Predicate{
			Field: fieldX.String(),
			Op:    comparison.LtOrEq,
			Arg:   fieldY,
		})
	}
}
